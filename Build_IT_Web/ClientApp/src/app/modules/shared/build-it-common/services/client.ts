//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.17.0.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class BeamCalculatorClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Calculates the beam
     * @return Returns the calculations
     */
    calculateBeam(beamData: CalculateBeamCommand): Observable<BeamCalculationResultsResource> {
        let url_ = this.baseUrl + "/api/BeamCalculator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(beamData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalculateBeam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalculateBeam(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BeamCalculationResultsResource>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BeamCalculationResultsResource>;
        }));
    }

    protected processCalculateBeam(response: HttpResponseBase): Observable<BeamCalculationResultsResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = BeamCalculationResultsResource.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the input is invalid", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ClaimsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllClaims(): Observable<ClaimResource[]> {
        let url_ = this.baseUrl + "/api/Claims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllClaims(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimResource[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimResource[]>;
        }));
    }

    protected processGetAllClaims(response: HttpResponseBase): Observable<ClaimResource[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClaimResource.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getClaimsForProjectForCurrentUser(projectId: number): Observable<ClaimResource[]> {
        let url_ = this.baseUrl + "/api/Claims/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClaimsForProjectForCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClaimsForProjectForCurrentUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimResource[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimResource[]>;
        }));
    }

    protected processGetClaimsForProjectForCurrentUser(response: HttpResponseBase): Observable<ClaimResource[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClaimResource.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getClaimsForProjectForUser(userId: string | null, projectId: number): Observable<ClaimResource[]> {
        let url_ = this.baseUrl + "/api/Claims/{userId}/{projectId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClaimsForProjectForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClaimsForProjectForUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimResource[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimResource[]>;
        }));
    }

    protected processGetClaimsForProjectForUser(response: HttpResponseBase): Observable<ClaimResource[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClaimResource.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkIfUserHasClaimInProject(userId: string | null, projectId: number, claimId: number | undefined, claimName: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Claims/{userId}/{projectId}/{claimName}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (claimName === undefined || claimName === null)
            throw new Error("The parameter 'claimName' must be defined.");
        url_ = url_.replace("{claimName}", encodeURIComponent("" + claimName));
        if (claimId === null)
            throw new Error("The parameter 'claimId' cannot be null.");
        else if (claimId !== undefined)
            url_ += "claimId=" + encodeURIComponent("" + claimId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckIfUserHasClaimInProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckIfUserHasClaimInProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckIfUserHasClaimInProject(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    assignClaimToDesignerForProject(userId: string | null, projectId: number, claimId: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Claims/{userId}/{projectId}/{claimId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (claimId === undefined || claimId === null)
            throw new Error("The parameter 'claimId' must be defined.");
        url_ = url_.replace("{claimId}", encodeURIComponent("" + claimId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignClaimToDesignerForProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignClaimToDesignerForProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAssignClaimToDesignerForProject(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeClaimFromDesignerInProject(userId: string | null, projectId: number, claimId: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Claims/{userId}/{projectId}/{claimId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (claimId === undefined || claimId === null)
            throw new Error("The parameter 'claimId' must be defined.");
        url_ = url_.replace("{claimId}", encodeURIComponent("" + claimId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveClaimFromDesignerInProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveClaimFromDesignerInProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processRemoveClaimFromDesignerInProject(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CompaniesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(): Observable<CompanyResource[]> {
        let url_ = this.baseUrl + "/api/Companies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyResource[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyResource[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CompanyResource[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CompanyResource.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(createCompanyCommand: CreateCompanyCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Companies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createCompanyCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(updateCompanyCommand: UpdateCompanyCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Companies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateCompanyCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllForUser(userId: string | null): Observable<CompanyResource[]> {
        let url_ = this.baseUrl + "/api/Companies/forUser/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllForUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyResource[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyResource[]>;
        }));
    }

    protected processGetAllForUser(response: HttpResponseBase): Observable<CompanyResource[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CompanyResource.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllForCurrentUser(): Observable<CompanyResource[]> {
        let url_ = this.baseUrl + "/api/Companies/currentUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllForCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllForCurrentUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyResource[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyResource[]>;
        }));
    }

    protected processGetAllForCurrentUser(response: HttpResponseBase): Observable<CompanyResource[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CompanyResource.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(companyId: number): Observable<CompanyResource> {
        let url_ = this.baseUrl + "/api/Companies/{companyId}";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyResource>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyResource>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CompanyResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(companyId: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Companies/{companyId}";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    assignUser(companyId: number, userMail: string | null): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Companies/{companyId}/{userMail}";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        if (userMail === undefined || userMail === null)
            throw new Error("The parameter 'userMail' must be defined.");
        url_ = url_.replace("{userMail}", encodeURIComponent("" + userMail));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAssignUser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUsersForCompany(companyId: number): Observable<UserResource[]> {
        let url_ = this.baseUrl + "/api/Companies/{companyId}/users";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersForCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersForCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserResource[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserResource[]>;
        }));
    }

    protected processGetUsersForCompany(response: HttpResponseBase): Observable<UserResource[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserResource.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DeadLoadsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllDeadLoadsForProject(companyId: number, projectId: number): Observable<DeadLoadResource[]> {
        let url_ = this.baseUrl + "/api/DeadLoads/{companyId}/{projectId}";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDeadLoadsForProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDeadLoadsForProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeadLoadResource[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeadLoadResource[]>;
        }));
    }

    protected processGetAllDeadLoadsForProject(response: HttpResponseBase): Observable<DeadLoadResource[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeadLoadResource.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllDeadLoadLayers(companyId: number, projectId: number, deadLoadId: number): Observable<DeadLoadLayerResource[]> {
        let url_ = this.baseUrl + "/api/DeadLoads/{companyId}/{projectId}/{deadLoadId}/layers";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (deadLoadId === undefined || deadLoadId === null)
            throw new Error("The parameter 'deadLoadId' must be defined.");
        url_ = url_.replace("{deadLoadId}", encodeURIComponent("" + deadLoadId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDeadLoadLayers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDeadLoadLayers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeadLoadLayerResource[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeadLoadLayerResource[]>;
        }));
    }

    protected processGetAllDeadLoadLayers(response: HttpResponseBase): Observable<DeadLoadLayerResource[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeadLoadLayerResource.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(companyId: number, projectId: number, createDeadLoadCommand: CreateDeadLoadCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/DeadLoads/{companyId}/{projectId}/create";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createDeadLoadCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveDeadLoadLayers(companyId: number, projectId: number, deadLoadId: number, saveDeadLoadLayersCommand: SaveDeadLoadLayersCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/DeadLoads/{companyId}/{projectId}/{deadLoadId}/layers/create";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (deadLoadId === undefined || deadLoadId === null)
            throw new Error("The parameter 'deadLoadId' must be defined.");
        url_ = url_.replace("{deadLoadId}", encodeURIComponent("" + deadLoadId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(saveDeadLoadLayersCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDeadLoadLayers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDeadLoadLayers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveDeadLoadLayers(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get all categories
     * @return Returns the categories
     */
    getAllCategories(): Observable<CategoryResultResource[]> {
        let url_ = this.baseUrl + "/api/DeadLoads/categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryResultResource[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryResultResource[]>;
        }));
    }

    protected processGetAllCategories(response: HttpResponseBase): Observable<CategoryResultResource[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryResultResource.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the input is invalid", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get all subcategories
     * @return Returns the categories
     */
    getAllSubcategories(categoryId: number): Observable<SubcategoryResultResource[]> {
        let url_ = this.baseUrl + "/api/DeadLoads/{categoryId}/subcategories";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubcategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubcategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubcategoryResultResource[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubcategoryResultResource[]>;
        }));
    }

    protected processGetAllSubcategories(response: HttpResponseBase): Observable<SubcategoryResultResource[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubcategoryResultResource.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the input is invalid", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If the result is not found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get all materials
     * @return Returns the materials
     */
    getAllMaterials(subcategoryId: number): Observable<MaterialResultResource[]> {
        let url_ = this.baseUrl + "/api/DeadLoads/{subcategoryId}/materials";
        if (subcategoryId === undefined || subcategoryId === null)
            throw new Error("The parameter 'subcategoryId' must be defined.");
        url_ = url_.replace("{subcategoryId}", encodeURIComponent("" + subcategoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMaterials(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMaterials(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MaterialResultResource[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MaterialResultResource[]>;
        }));
    }

    protected processGetAllMaterials(response: HttpResponseBase): Observable<MaterialResultResource[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MaterialResultResource.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the input is invalid", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If the result is not found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get material
     * @return Returns the material
     */
    getMaterial(materialId: number): Observable<MaterialResultResource> {
        let url_ = this.baseUrl + "/api/DeadLoads/materials/{materialId}";
        if (materialId === undefined || materialId === null)
            throw new Error("The parameter 'materialId' must be defined.");
        url_ = url_.replace("{materialId}", encodeURIComponent("" + materialId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MaterialResultResource>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MaterialResultResource>;
        }));
    }

    protected processGetMaterial(response: HttpResponseBase): Observable<MaterialResultResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialResultResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the input is invalid", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("If the result is not found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProjectsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(): Observable<ProjectResource[]> {
        let url_ = this.baseUrl + "/api/Projects";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectResource[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectResource[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ProjectResource[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectResource.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(createProjectCommand: CreateProjectCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Projects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createProjectCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(updateProjectCommand: UpdateProjectCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Projects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateProjectCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(projectId: number): Observable<ProjectResource> {
        let url_ = this.baseUrl + "/api/Projects/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectResource>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectResource>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProjectResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(projectId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Projects/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllProjectsForCompany(companyId: number): Observable<ProjectResource[]> {
        let url_ = this.baseUrl + "/api/Projects/forCompany/{companyId}";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProjectsForCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProjectsForCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectResource[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectResource[]>;
        }));
    }

    protected processGetAllProjectsForCompany(response: HttpResponseBase): Observable<ProjectResource[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectResource.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SnowLoadsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllSnowLoadsForProject(companyId: number, projectId: number): Observable<SnowLoadResource[]> {
        let url_ = this.baseUrl + "/api/SnowLoads/{companyId}/{projectId}";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSnowLoadsForProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSnowLoadsForProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SnowLoadResource[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SnowLoadResource[]>;
        }));
    }

    protected processGetAllSnowLoadsForProject(response: HttpResponseBase): Observable<SnowLoadResource[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SnowLoadResource.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(companyId: number, projectId: number, createSnowLoadCommand: CreateSnowLoadCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/SnowLoads/{companyId}/{projectId}/create";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createSnowLoadCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class BeamCalculationResultsResource implements IBeamCalculationResultsResource {
    normalForces?: BeamCalculationResultResource[] | undefined;
    shearForces?: BeamCalculationResultResource[] | undefined;
    bendingMoments?: BeamCalculationResultResource[] | undefined;
    horizontalDeflections?: BeamCalculationResultResource[] | undefined;
    verticalDeflections?: BeamCalculationResultResource[] | undefined;
    rotations?: BeamCalculationResultResource[] | undefined;

    constructor(data?: IBeamCalculationResultsResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["normalForces"])) {
                this.normalForces = [] as any;
                for (let item of _data["normalForces"])
                    this.normalForces!.push(BeamCalculationResultResource.fromJS(item));
            }
            if (Array.isArray(_data["shearForces"])) {
                this.shearForces = [] as any;
                for (let item of _data["shearForces"])
                    this.shearForces!.push(BeamCalculationResultResource.fromJS(item));
            }
            if (Array.isArray(_data["bendingMoments"])) {
                this.bendingMoments = [] as any;
                for (let item of _data["bendingMoments"])
                    this.bendingMoments!.push(BeamCalculationResultResource.fromJS(item));
            }
            if (Array.isArray(_data["horizontalDeflections"])) {
                this.horizontalDeflections = [] as any;
                for (let item of _data["horizontalDeflections"])
                    this.horizontalDeflections!.push(BeamCalculationResultResource.fromJS(item));
            }
            if (Array.isArray(_data["verticalDeflections"])) {
                this.verticalDeflections = [] as any;
                for (let item of _data["verticalDeflections"])
                    this.verticalDeflections!.push(BeamCalculationResultResource.fromJS(item));
            }
            if (Array.isArray(_data["rotations"])) {
                this.rotations = [] as any;
                for (let item of _data["rotations"])
                    this.rotations!.push(BeamCalculationResultResource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BeamCalculationResultsResource {
        data = typeof data === 'object' ? data : {};
        let result = new BeamCalculationResultsResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.normalForces)) {
            data["normalForces"] = [];
            for (let item of this.normalForces)
                data["normalForces"].push(item.toJSON());
        }
        if (Array.isArray(this.shearForces)) {
            data["shearForces"] = [];
            for (let item of this.shearForces)
                data["shearForces"].push(item.toJSON());
        }
        if (Array.isArray(this.bendingMoments)) {
            data["bendingMoments"] = [];
            for (let item of this.bendingMoments)
                data["bendingMoments"].push(item.toJSON());
        }
        if (Array.isArray(this.horizontalDeflections)) {
            data["horizontalDeflections"] = [];
            for (let item of this.horizontalDeflections)
                data["horizontalDeflections"].push(item.toJSON());
        }
        if (Array.isArray(this.verticalDeflections)) {
            data["verticalDeflections"] = [];
            for (let item of this.verticalDeflections)
                data["verticalDeflections"].push(item.toJSON());
        }
        if (Array.isArray(this.rotations)) {
            data["rotations"] = [];
            for (let item of this.rotations)
                data["rotations"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBeamCalculationResultsResource {
    normalForces?: BeamCalculationResultResource[] | undefined;
    shearForces?: BeamCalculationResultResource[] | undefined;
    bendingMoments?: BeamCalculationResultResource[] | undefined;
    horizontalDeflections?: BeamCalculationResultResource[] | undefined;
    verticalDeflections?: BeamCalculationResultResource[] | undefined;
    rotations?: BeamCalculationResultResource[] | undefined;
}

export class BeamCalculationResultResource implements IBeamCalculationResultResource {
    position?: number;
    value?: number;

    constructor(data?: IBeamCalculationResultResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.position = _data["position"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): BeamCalculationResultResource {
        data = typeof data === 'object' ? data : {};
        let result = new BeamCalculationResultResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["value"] = this.value;
        return data;
    }
}

export interface IBeamCalculationResultResource {
    position?: number;
    value?: number;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class CalculateBeamCommand implements ICalculateBeamCommand {
    beamResource?: BeamResource | undefined;

    constructor(data?: ICalculateBeamCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.beamResource = _data["beamResource"] ? BeamResource.fromJS(_data["beamResource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CalculateBeamCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CalculateBeamCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beamResource"] = this.beamResource ? this.beamResource.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICalculateBeamCommand {
    beamResource?: BeamResource | undefined;
}

export class BeamResource implements IBeamResource {
    includeSelfWeight?: boolean;
    spanDatas?: SpanResource[] | undefined;

    constructor(data?: IBeamResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.includeSelfWeight = _data["includeSelfWeight"];
            if (Array.isArray(_data["spanDatas"])) {
                this.spanDatas = [] as any;
                for (let item of _data["spanDatas"])
                    this.spanDatas!.push(SpanResource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BeamResource {
        data = typeof data === 'object' ? data : {};
        let result = new BeamResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["includeSelfWeight"] = this.includeSelfWeight;
        if (Array.isArray(this.spanDatas)) {
            data["spanDatas"] = [];
            for (let item of this.spanDatas)
                data["spanDatas"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBeamResource {
    includeSelfWeight?: boolean;
    spanDatas?: SpanResource[] | undefined;
}

export class SpanResource implements ISpanResource {
    length?: number;
    material?: MaterialResource | undefined;
    section?: SectionResource | undefined;
    leftNode?: NodeResource | undefined;
    rightNode?: NodeResource | undefined;
    includeSelfWeight?: boolean;
    continuousLoads?: ContinuousLoadResource[] | undefined;
    pointLoads?: PointLoadResource[] | undefined;

    constructor(data?: ISpanResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.length = _data["length"];
            this.material = _data["material"] ? MaterialResource.fromJS(_data["material"]) : <any>undefined;
            this.section = _data["section"] ? SectionResource.fromJS(_data["section"]) : <any>undefined;
            this.leftNode = _data["leftNode"] ? NodeResource.fromJS(_data["leftNode"]) : <any>undefined;
            this.rightNode = _data["rightNode"] ? NodeResource.fromJS(_data["rightNode"]) : <any>undefined;
            this.includeSelfWeight = _data["includeSelfWeight"];
            if (Array.isArray(_data["continuousLoads"])) {
                this.continuousLoads = [] as any;
                for (let item of _data["continuousLoads"])
                    this.continuousLoads!.push(ContinuousLoadResource.fromJS(item));
            }
            if (Array.isArray(_data["pointLoads"])) {
                this.pointLoads = [] as any;
                for (let item of _data["pointLoads"])
                    this.pointLoads!.push(PointLoadResource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SpanResource {
        data = typeof data === 'object' ? data : {};
        let result = new SpanResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["length"] = this.length;
        data["material"] = this.material ? this.material.toJSON() : <any>undefined;
        data["section"] = this.section ? this.section.toJSON() : <any>undefined;
        data["leftNode"] = this.leftNode ? this.leftNode.toJSON() : <any>undefined;
        data["rightNode"] = this.rightNode ? this.rightNode.toJSON() : <any>undefined;
        data["includeSelfWeight"] = this.includeSelfWeight;
        if (Array.isArray(this.continuousLoads)) {
            data["continuousLoads"] = [];
            for (let item of this.continuousLoads)
                data["continuousLoads"].push(item.toJSON());
        }
        if (Array.isArray(this.pointLoads)) {
            data["pointLoads"] = [];
            for (let item of this.pointLoads)
                data["pointLoads"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISpanResource {
    length?: number;
    material?: MaterialResource | undefined;
    section?: SectionResource | undefined;
    leftNode?: NodeResource | undefined;
    rightNode?: NodeResource | undefined;
    includeSelfWeight?: boolean;
    continuousLoads?: ContinuousLoadResource[] | undefined;
    pointLoads?: PointLoadResource[] | undefined;
}

export class MaterialResource implements IMaterialResource {
    youngModulus?: number;
    density?: number;
    thermalExpansionCoefficient?: number;

    constructor(data?: IMaterialResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.youngModulus = _data["youngModulus"];
            this.density = _data["density"];
            this.thermalExpansionCoefficient = _data["thermalExpansionCoefficient"];
        }
    }

    static fromJS(data: any): MaterialResource {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["youngModulus"] = this.youngModulus;
        data["density"] = this.density;
        data["thermalExpansionCoefficient"] = this.thermalExpansionCoefficient;
        return data;
    }
}

export interface IMaterialResource {
    youngModulus?: number;
    density?: number;
    thermalExpansionCoefficient?: number;
}

export class SectionResource implements ISectionResource {
    momentOfInteria?: number;
    area?: number;
    circumference?: number;
    solidHeight?: number;

    constructor(data?: ISectionResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.momentOfInteria = _data["momentOfInteria"];
            this.area = _data["area"];
            this.circumference = _data["circumference"];
            this.solidHeight = _data["solidHeight"];
        }
    }

    static fromJS(data: any): SectionResource {
        data = typeof data === 'object' ? data : {};
        let result = new SectionResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["momentOfInteria"] = this.momentOfInteria;
        data["area"] = this.area;
        data["circumference"] = this.circumference;
        data["solidHeight"] = this.solidHeight;
        return data;
    }
}

export interface ISectionResource {
    momentOfInteria?: number;
    area?: number;
    circumference?: number;
    solidHeight?: number;
}

export class NodeResource implements INodeResource {
    angle?: number;
    nodeType?: NodeType;
    pointLoads?: PointLoadResource[] | undefined;

    constructor(data?: INodeResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.angle = _data["angle"];
            this.nodeType = _data["nodeType"];
            if (Array.isArray(_data["pointLoads"])) {
                this.pointLoads = [] as any;
                for (let item of _data["pointLoads"])
                    this.pointLoads!.push(PointLoadResource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NodeResource {
        data = typeof data === 'object' ? data : {};
        let result = new NodeResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["angle"] = this.angle;
        data["nodeType"] = this.nodeType;
        if (Array.isArray(this.pointLoads)) {
            data["pointLoads"] = [];
            for (let item of this.pointLoads)
                data["pointLoads"].push(item.toJSON());
        }
        return data;
    }
}

export interface INodeResource {
    angle?: number;
    nodeType?: NodeType;
    pointLoads?: PointLoadResource[] | undefined;
}

export enum NodeType {
    FixedNode = 0,
    FreeNode = 1,
    Hinge = 2,
    PinNode = 3,
    SleeveNode = 4,
    SupportedNode = 5,
    SupportedNodeWithHinge = 6,
    TelescopeNode = 7,
}

export class PointLoadResource implements IPointLoadResource {
    position?: number;
    value?: number;
    angle?: number;
    pointLoadType?: PointLoadType;

    constructor(data?: IPointLoadResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.position = _data["position"];
            this.value = _data["value"];
            this.angle = _data["angle"];
            this.pointLoadType = _data["pointLoadType"];
        }
    }

    static fromJS(data: any): PointLoadResource {
        data = typeof data === 'object' ? data : {};
        let result = new PointLoadResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["value"] = this.value;
        data["angle"] = this.angle;
        data["pointLoadType"] = this.pointLoadType;
        return data;
    }
}

export interface IPointLoadResource {
    position?: number;
    value?: number;
    angle?: number;
    pointLoadType?: PointLoadType;
}

export enum PointLoadType {
    AngledLoad = 0,
    BendingMoment = 1,
    HorizontalDisplacement = 2,
    NormalLoad = 3,
    RotationDisplacement = 4,
    ShearLoad = 5,
    VerticalDisplacement = 6,
}

export class ContinuousLoadResource implements IContinuousLoadResource {
    startPosition?: number;
    endPosition?: number;
    startValue?: number;
    endValue?: number;
    angle?: number;
    continuousLoadType?: ContinuousLoadType;

    constructor(data?: IContinuousLoadResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startPosition = _data["startPosition"];
            this.endPosition = _data["endPosition"];
            this.startValue = _data["startValue"];
            this.endValue = _data["endValue"];
            this.angle = _data["angle"];
            this.continuousLoadType = _data["continuousLoadType"];
        }
    }

    static fromJS(data: any): ContinuousLoadResource {
        data = typeof data === 'object' ? data : {};
        let result = new ContinuousLoadResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startPosition"] = this.startPosition;
        data["endPosition"] = this.endPosition;
        data["startValue"] = this.startValue;
        data["endValue"] = this.endValue;
        data["angle"] = this.angle;
        data["continuousLoadType"] = this.continuousLoadType;
        return data;
    }
}

export interface IContinuousLoadResource {
    startPosition?: number;
    endPosition?: number;
    startValue?: number;
    endValue?: number;
    angle?: number;
    continuousLoadType?: ContinuousLoadType;
}

export enum ContinuousLoadType {
    AlongTemperatureDifferenceLoad = 0,
    ContinuousAngledLoad = 1,
    ContinuousBendingMomentLoad = 2,
    ContinuousNormalLoad = 3,
    ContinuousShearLoad = 4,
    SpanExtendLoad = 5,
    UpDownTemperatureDifferenceLoad = 6,
}

export class ClaimResource implements IClaimResource {
    id?: number;
    name?: string | undefined;

    constructor(data?: IClaimResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ClaimResource {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IClaimResource {
    id?: number;
    name?: string | undefined;
}

export class CompanyResource implements ICompanyResource {
    id?: number;
    name?: string | undefined;
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;

    constructor(data?: ICompanyResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
        }
    }

    static fromJS(data: any): CompanyResource {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        return data;
    }
}

export interface ICompanyResource {
    id?: number;
    name?: string | undefined;
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;
}

export class CreateCompanyCommand implements ICreateCompanyCommand {
    name?: string | undefined;

    constructor(data?: ICreateCompanyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateCompanyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCompanyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateCompanyCommand {
    name?: string | undefined;
}

export class UpdateCompanyCommand implements IUpdateCompanyCommand {
    id?: number;
    name?: string | undefined;

    constructor(data?: IUpdateCompanyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateCompanyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCompanyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateCompanyCommand {
    id?: number;
    name?: string | undefined;
}

export class UserResource implements IUserResource {
    id?: string | undefined;
    userName?: string | undefined;

    constructor(data?: IUserResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): UserResource {
        data = typeof data === 'object' ? data : {};
        let result = new UserResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IUserResource {
    id?: string | undefined;
    userName?: string | undefined;
}

export class DeadLoadResource implements IDeadLoadResource {
    id?: number;
    name?: string | undefined;

    constructor(data?: IDeadLoadResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DeadLoadResource {
        data = typeof data === 'object' ? data : {};
        let result = new DeadLoadResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IDeadLoadResource {
    id?: number;
    name?: string | undefined;
}

export class DeadLoadLayerResource implements IDeadLoadLayerResource {
    id?: number;
    materialId?: number;
    deadLoadId?: number;
    width?: number | undefined;
    height?: number | undefined;
    length?: number | undefined;
    previousDeadLoadId?: number | undefined;

    constructor(data?: IDeadLoadLayerResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.materialId = _data["materialId"];
            this.deadLoadId = _data["deadLoadId"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.length = _data["length"];
            this.previousDeadLoadId = _data["previousDeadLoadId"];
        }
    }

    static fromJS(data: any): DeadLoadLayerResource {
        data = typeof data === 'object' ? data : {};
        let result = new DeadLoadLayerResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["materialId"] = this.materialId;
        data["deadLoadId"] = this.deadLoadId;
        data["width"] = this.width;
        data["height"] = this.height;
        data["length"] = this.length;
        data["previousDeadLoadId"] = this.previousDeadLoadId;
        return data;
    }
}

export interface IDeadLoadLayerResource {
    id?: number;
    materialId?: number;
    deadLoadId?: number;
    width?: number | undefined;
    height?: number | undefined;
    length?: number | undefined;
    previousDeadLoadId?: number | undefined;
}

export class CreateDeadLoadCommand implements ICreateDeadLoadCommand {
    companyId?: number;
    projectId?: number;
    name?: string | undefined;

    constructor(data?: ICreateDeadLoadCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.projectId = _data["projectId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateDeadLoadCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDeadLoadCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["projectId"] = this.projectId;
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateDeadLoadCommand {
    companyId?: number;
    projectId?: number;
    name?: string | undefined;
}

export class SaveDeadLoadLayersCommand implements ISaveDeadLoadLayersCommand {
    companyId?: number;
    projectId?: number;
    deadLoadId?: number;
    deadLoadLayers?: SaveDeadLoadLayer[] | undefined;

    constructor(data?: ISaveDeadLoadLayersCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.projectId = _data["projectId"];
            this.deadLoadId = _data["deadLoadId"];
            if (Array.isArray(_data["deadLoadLayers"])) {
                this.deadLoadLayers = [] as any;
                for (let item of _data["deadLoadLayers"])
                    this.deadLoadLayers!.push(SaveDeadLoadLayer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SaveDeadLoadLayersCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SaveDeadLoadLayersCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["projectId"] = this.projectId;
        data["deadLoadId"] = this.deadLoadId;
        if (Array.isArray(this.deadLoadLayers)) {
            data["deadLoadLayers"] = [];
            for (let item of this.deadLoadLayers)
                data["deadLoadLayers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISaveDeadLoadLayersCommand {
    companyId?: number;
    projectId?: number;
    deadLoadId?: number;
    deadLoadLayers?: SaveDeadLoadLayer[] | undefined;
}

export class SaveDeadLoadLayer implements ISaveDeadLoadLayer {
    materialId?: number;
    width?: number | undefined;
    height?: number | undefined;
    length?: number | undefined;
    previousDeadLoadId?: number | undefined;

    constructor(data?: ISaveDeadLoadLayer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialId = _data["materialId"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.length = _data["length"];
            this.previousDeadLoadId = _data["previousDeadLoadId"];
        }
    }

    static fromJS(data: any): SaveDeadLoadLayer {
        data = typeof data === 'object' ? data : {};
        let result = new SaveDeadLoadLayer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["width"] = this.width;
        data["height"] = this.height;
        data["length"] = this.length;
        data["previousDeadLoadId"] = this.previousDeadLoadId;
        return data;
    }
}

export interface ISaveDeadLoadLayer {
    materialId?: number;
    width?: number | undefined;
    height?: number | undefined;
    length?: number | undefined;
    previousDeadLoadId?: number | undefined;
}

export class CategoryResultResource implements ICategoryResultResource {
    id?: number;
    name?: string | undefined;
    subcategories?: SubcategoryResultResource[] | undefined;

    constructor(data?: ICategoryResultResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["subcategories"])) {
                this.subcategories = [] as any;
                for (let item of _data["subcategories"])
                    this.subcategories!.push(SubcategoryResultResource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryResultResource {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryResultResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.subcategories)) {
            data["subcategories"] = [];
            for (let item of this.subcategories)
                data["subcategories"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategoryResultResource {
    id?: number;
    name?: string | undefined;
    subcategories?: SubcategoryResultResource[] | undefined;
}

export class SubcategoryResultResource implements ISubcategoryResultResource {
    id?: number;
    name?: string | undefined;
    documentName?: string | undefined;
    categoryId?: number;
    category?: CategoryResultResource | undefined;
    materials?: MaterialResultResource[] | undefined;

    constructor(data?: ISubcategoryResultResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.documentName = _data["documentName"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"] ? CategoryResultResource.fromJS(_data["category"]) : <any>undefined;
            if (Array.isArray(_data["materials"])) {
                this.materials = [] as any;
                for (let item of _data["materials"])
                    this.materials!.push(MaterialResultResource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubcategoryResultResource {
        data = typeof data === 'object' ? data : {};
        let result = new SubcategoryResultResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["documentName"] = this.documentName;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        if (Array.isArray(this.materials)) {
            data["materials"] = [];
            for (let item of this.materials)
                data["materials"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISubcategoryResultResource {
    id?: number;
    name?: string | undefined;
    documentName?: string | undefined;
    categoryId?: number;
    category?: CategoryResultResource | undefined;
    materials?: MaterialResultResource[] | undefined;
}

export class MaterialResultResource implements IMaterialResultResource {
    id?: number;
    name?: string | undefined;
    minimumDensity?: number;
    maximumDensity?: number;
    unit?: LoadUnit;
    documentName?: string | undefined;
    comments?: string | undefined;
    subcategoryId?: number;
    subcategory?: SubcategoryResultResource | undefined;
    materialAdditions?: MaterialAdditionResult[] | undefined;

    constructor(data?: IMaterialResultResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.minimumDensity = _data["minimumDensity"];
            this.maximumDensity = _data["maximumDensity"];
            this.unit = _data["unit"];
            this.documentName = _data["documentName"];
            this.comments = _data["comments"];
            this.subcategoryId = _data["subcategoryId"];
            this.subcategory = _data["subcategory"] ? SubcategoryResultResource.fromJS(_data["subcategory"]) : <any>undefined;
            if (Array.isArray(_data["materialAdditions"])) {
                this.materialAdditions = [] as any;
                for (let item of _data["materialAdditions"])
                    this.materialAdditions!.push(MaterialAdditionResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MaterialResultResource {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialResultResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["minimumDensity"] = this.minimumDensity;
        data["maximumDensity"] = this.maximumDensity;
        data["unit"] = this.unit;
        data["documentName"] = this.documentName;
        data["comments"] = this.comments;
        data["subcategoryId"] = this.subcategoryId;
        data["subcategory"] = this.subcategory ? this.subcategory.toJSON() : <any>undefined;
        if (Array.isArray(this.materialAdditions)) {
            data["materialAdditions"] = [];
            for (let item of this.materialAdditions)
                data["materialAdditions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMaterialResultResource {
    id?: number;
    name?: string | undefined;
    minimumDensity?: number;
    maximumDensity?: number;
    unit?: LoadUnit;
    documentName?: string | undefined;
    comments?: string | undefined;
    subcategoryId?: number;
    subcategory?: SubcategoryResultResource | undefined;
    materialAdditions?: MaterialAdditionResult[] | undefined;
}

export enum LoadUnit {
    Kilonewton = 0,
    Kilonewton_per_meter = 1,
    Kilonewton_per_square_meter = 2,
    Kilonewton_per_cubic_meter = 3,
}

export class MaterialAdditionResult implements IMaterialAdditionResult {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    value?: number;

    constructor(data?: IMaterialAdditionResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): MaterialAdditionResult {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialAdditionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["value"] = this.value;
        return data;
    }
}

export interface IMaterialAdditionResult {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    value?: number;
}

export class ProjectResource implements IProjectResource {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    created?: Date;
    lastModified?: Date | undefined;

    constructor(data?: IProjectResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectResource {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        return data;
    }
}

export interface IProjectResource {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    created?: Date;
    lastModified?: Date | undefined;
}

export class CreateProjectCommand implements ICreateProjectCommand {
    companyId?: number;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreateProjectCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateProjectCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateProjectCommand {
    companyId?: number;
    name?: string | undefined;
    description?: string | undefined;
}

export class UpdateProjectCommand implements IUpdateProjectCommand {
    id?: number;
    companyId?: number;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IUpdateProjectCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateProjectCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProjectCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IUpdateProjectCommand {
    id?: number;
    companyId?: number;
    name?: string | undefined;
    description?: string | undefined;
}

export class SnowLoadResource implements ISnowLoadResource {
    id?: number;
    name?: string | undefined;
    snowLoadRoofId?: number;

    constructor(data?: ISnowLoadResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.snowLoadRoofId = _data["snowLoadRoofId"];
        }
    }

    static fromJS(data: any): SnowLoadResource {
        data = typeof data === 'object' ? data : {};
        let result = new SnowLoadResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["snowLoadRoofId"] = this.snowLoadRoofId;
        return data;
    }
}

export interface ISnowLoadResource {
    id?: number;
    name?: string | undefined;
    snowLoadRoofId?: number;
}

export class CreateSnowLoadCommand implements ICreateSnowLoadCommand {
    companyId?: number;
    projectId?: number;
    name?: string | undefined;
    roofType?: RoofType;

    constructor(data?: ICreateSnowLoadCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.projectId = _data["projectId"];
            this.name = _data["name"];
            this.roofType = _data["roofType"];
        }
    }

    static fromJS(data: any): CreateSnowLoadCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSnowLoadCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["projectId"] = this.projectId;
        data["name"] = this.name;
        data["roofType"] = this.roofType;
        return data;
    }
}

export interface ICreateSnowLoadCommand {
    companyId?: number;
    projectId?: number;
    name?: string | undefined;
    roofType?: RoofType;
}

export enum RoofType {
    None = 0,
    Monopitch = 1,
    Pitched = 2,
    MultiSpan = 3,
    Cylindrical = 4,
    DriftingAtProjectionsObstructions = 5,
    RoofAbuttingToTallerConstruction = 6,
    Snowguards = 7,
    SnowOverhanging = 8,
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}